name: GKE Issue Personal Admin Kubeconfig

on:
  workflow_dispatch:
    inputs:
      username:
        description: "Person's name (used in SA and kubeconfig filename), e.g., alex"
        required: true
      token_duration:
        description: "Requested token lifetime (e.g., 12h, 1h, 30m). Cluster may cap this."
        required: false
        default: "12h"

jobs:
  issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write   # REQUIRED for OIDC to GCP
    env:
      # Fixed cluster name per your request
      GKE_CLUSTER_NAME: ecommerce-app-cluster
      # From repo secrets (set these once)
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_REGION: ${{ secrets.GCP_REGION }}
      TOKEN_DURATION: ${{ inputs.token_duration }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud (OIDC)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Setup gcloud & kubectl
        uses: google-github-actions/setup-gcloud@v2

      - name: Fetch cluster credentials
        run: |
          gcloud container clusters get-credentials "${GKE_CLUSTER_NAME}" \
            --region "${GCP_REGION}" \
            --project "${GCP_PROJECT_ID}"
          kubectl cluster-info

      - name: Normalize username
        id: norm
        run: |
          # Lowercase, keep a-z0-9- only, trim leading/trailing dashes, cap length
          SAFE=$(echo "${{ inputs.username }}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g' | sed -E 's/^-+|-+$//g' | cut -c1-50)
          echo "safe=${SAFE}" >> $GITHUB_OUTPUT

      - name: Create ServiceAccount in kube-system
        env:
          SA_NS: kube-system
        run: |
          SA="${{ steps.norm.outputs.safe }}-sa"
          kubectl create serviceaccount "${SA}" -n "${SA_NS}" --dry-run=client -o yaml | kubectl apply -f -
          echo "SA_NAME=${SA}" >> $GITHUB_ENV
          echo "SA_NS=${SA_NS}" >> $GITHUB_ENV

      - name: Grant cluster-admin (full control)
        run: |
          kubectl create clusterrolebinding "${SA_NAME}-cluster-admin" \
            --clusterrole=cluster-admin \
            --serviceaccount="${SA_NS}:${SA_NAME}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Mint short-lived token
        id: token
        run: |
          set -e
          TOKEN=$(kubectl -n "${SA_NS}" create token "${SA_NAME}" --duration="${TOKEN_DURATION}")
          echo "token=${TOKEN}" >> $GITHUB_OUTPUT

      - name: Build personal kubeconfig (cluster-admin)
        id: kcfg
        run: |
          SAFE="${{ steps.norm.outputs.safe }}"
          CUR_CTX=$(kubectl config current-context)
          CLUSTER_NAME_CTX=$(kubectl config view -o jsonpath='{.contexts[?(@.name=="'"$CUR_CTX"'")].context.cluster}')
          SERVER=$(kubectl config view -o jsonpath='{.clusters[?(@.name=="'"$CLUSTER_NAME_CTX"'")].cluster.server}')
          CA_B64=$(kubectl config view --raw -o jsonpath='{.clusters[?(@.name=="'"$CLUSTER_NAME_CTX"'")].cluster.certificate-authority-data}')
          echo "$CA_B64" | base64 -d > ca.crt

          OUT="kubeconfig-${SAFE}.yaml"
          CTX_NAME="${SAFE}-admin"

          # create kubeconfig without heredoc yaml
          kubectl config --kubeconfig "$OUT" set-cluster "$CLUSTER_NAME_CTX" \
            --server="$SERVER" \
            --certificate-authority=ca.crt \
            --embed-certs=true

          kubectl config --kubeconfig "$OUT" set-credentials "$SAFE" \
            --token="${{ steps.token.outputs.token }}"

          kubectl config --kubeconfig "$OUT" set-context "$CTX_NAME" \
            --cluster="$CLUSTER_NAME_CTX" \
            --user="$SAFE"

          kubectl config --kubeconfig "$OUT" use-context "$CTX_NAME"

          # clean up temp CA file
          rm -f ca.crt

          echo "out=${OUT}" >> $GITHUB_OUTPUT
